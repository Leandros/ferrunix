//! Utilities for auto-registration of types into the global registry.
//!
//! The global registry is available via [`Registry::global`].

use crate::types::RegisterFn;
use crate::{types::OnceCell, Registry};

/// The global, `'static` default [`Registry`]. It's constructed and accessible
/// via [`Registry::global`].
#[cfg(feature = "multithread")]
pub(crate) static DEFAULT_REGISTRY: OnceCell<Registry> = OnceCell::new();

#[cfg(all(not(feature = "multithread"), not(feature = "tokio")))]
thread_local! {
    /// The global, `'static` default [`Registry`]. It's constructed and accessible via
    /// [`Registry::global`] from the current thread only.
    ///
    /// Since this is a thread local, every thread will have it's own registry.
    ///
    /// To enable multithreaded registries, the `multithread` feature must be enabled.
    pub(crate) static DEFAULT_REGISTRY: OnceCell<std::rc::Rc<Registry>> = const { OnceCell::new() };
}

/// The global, `'static` default [`Registry`]. It's constructed and accessible
/// via [`Registry::global`].
#[cfg(feature = "tokio")]
pub(crate) static DEFAULT_REGISTRY: OnceCell<Registry> = OnceCell::const_new();

/// All auto-registration functions need to use this type for registration.
///
/// This is, usually, used by the derive macro, and not manually.
#[non_exhaustive]
pub struct RegistrationFunc(pub(crate) RegisterFn);

impl RegistrationFunc {
    /// Create a new [`RegistrationFunc`] from a `register` function.
    ///
    /// The `register` function gets passed a [`Registry`], which it must use to
    /// register one or more types.
    ///
    /// The function must not have any side-effects. It may be called
    /// concurrently, in parallel, and from any thread (not only the main
    /// thread).
    ///
    /// # Example
    /// ```no_run
    /// # use ferrunix_core::*;
    /// # use ferrunix_core::registration::*;
    /// #[derive(Debug)]
    /// struct StringTemplate {
    ///     template: &'static str,
    /// }
    ///
    /// // Usually, this `impl` is generated by the `Inject` proc-macro.
    /// impl StringTemplate {
    ///     pub(crate) fn register(registry: &Registry) {
    ///         registry
    ///             .transient::<StringTemplate>(|| StringTemplate { template: "" });
    ///     }
    /// }
    ///
    /// // The construction must be `const`.
    /// autoregister!(RegistrationFunc::new(
    ///     StringTemplate::register
    /// ));
    /// ```
    pub const fn new(register: RegisterFn) -> Self {
        Self(register)
    }
}

impl std::fmt::Debug for RegistrationFunc {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_tuple("RegistrationFunc").finish()
    }
}

// Create a new inventory for the auto-registration.
inventory::collect!(RegistrationFunc);

/// Use `autoregister` to register a new [`RegistrationFunc`].
pub use inventory::submit as autoregister;
