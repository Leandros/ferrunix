//! Utilities for auto-registration of types into the global registry.
//!
//! The global registry is available via [`Registry::global`].

use crate::{types::OnceCell, Registry};

/// The global, `'static` default [`Registry`]. It's constructed and accessible
/// via [`Registry::global`].
#[cfg(all(feature = "multithread", not(feature = "tokio")))]
pub(crate) static DEFAULT_REGISTRY: OnceCell<Registry> = OnceCell::new();

#[cfg(all(not(feature = "multithread"), not(feature = "tokio")))]
thread_local! {
    /// The global, `'static` default [`Registry`]. It's constructed and accessible via
    /// [`Registry::global`] from the current thread only.
    ///
    /// Since this is a thread local, every thread will have it's own registry.
    ///
    /// To enable multithreaded registries, the `multithread` feature must be enabled.
    pub(crate) static DEFAULT_REGISTRY: OnceCell<std::rc::Rc<Registry>> = const { OnceCell::new() };
}

/// The global, `'static` default [`Registry`]. It's constructed and accessible
/// via [`Registry::global`].
#[cfg(feature = "tokio")]
pub(crate) static DEFAULT_REGISTRY: OnceCell<Registry> = OnceCell::const_new();

/// Synchronous registration.
#[cfg(not(feature = "tokio"))]
mod unsync {
    use crate::Registry;

    /// Signature of the function for the registration; usually created via the `derive` macro.
    pub(crate) type RegisterFn = fn(&Registry) -> ();

    /// All auto-registration functions need to use this type for registration.
    ///
    /// This is, usually, used by the derive macro, and not manually.
    #[non_exhaustive]
    pub struct RegistrationFunc(pub(crate) RegisterFn);

    impl RegistrationFunc {
        /// Create a new [`RegistrationFunc`] from a `register` function.
        ///
        /// The `register` function gets passed a [`Registry`], which it must use to
        /// register one or more types.
        ///
        /// The function must not have any side-effects. It may be called
        /// concurrently, in parallel, and from any thread (not only the main
        /// thread).
        ///
        /// # Example
        /// ```no_run
        /// # use ferrunix_core::*;
        /// # use ferrunix_core::registration::*;
        /// #[derive(Debug)]
        /// struct StringTemplate {
        ///     template: &'static str,
        /// }
        ///
        /// // Usually, this `impl` is generated by the `Inject` proc-macro.
        /// impl StringTemplate {
        ///     pub(crate) fn register(registry: &Registry) {
        ///         registry
        ///             .transient::<StringTemplate>(|| StringTemplate { template: "" });
        ///     }
        /// }
        ///
        /// // The construction must be `const`.
        /// autoregister!(RegistrationFunc::new(
        ///     StringTemplate::register
        /// ));
        /// ```
        pub const fn new(register: RegisterFn) -> Self {
            Self(register)
        }
    }

    impl std::fmt::Debug for RegistrationFunc {
        fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            fmt.debug_tuple("RegistrationFunc").finish()
        }
    }

    // Create a new inventory for the auto-registration.
    inventory::collect!(RegistrationFunc);
}

/// Asynchronous registration.
#[cfg(feature = "tokio")]
mod sync {
    use crate::Registry;

    /// Signature of the function for the registration; usually created via the `derive` macro.
    pub(crate) type RegisterFn = for<'reg> fn(
        &'reg Registry,
    ) -> std::pin::Pin<
        Box<dyn std::future::Future<Output = ()> + Send + 'reg>,
    >;

    /// All auto-registration functions need to use this type for registration.
    ///
    /// This is, usually, used by the derive macro, and not manually.
    #[non_exhaustive]
    pub struct RegistrationFunc(pub(crate) RegisterFn);

    impl RegistrationFunc {
        /// Create a new [`RegistrationFunc`] from a `register` function.
        ///
        /// The `register` function gets passed a [`Registry`], which it must use to
        /// register one or more types.
        ///
        /// The function must not have any side-effects. It may be called
        /// concurrently, in parallel, and from any thread (not only the main
        /// thread).
        ///
        /// # Example
        /// ```no_run
        /// # use ferrunix_core::*;
        /// # use ferrunix_core::registration::*;
        /// #[derive(Debug)]
        /// struct StringTemplate {
        ///     template: &'static str,
        /// }
        ///
        /// // Usually, this `impl` is generated by the `Inject` proc-macro.
        /// impl StringTemplate {
        ///     pub(crate) fn register(registry: &Registry) {
        ///         registry
        ///             .transient::<StringTemplate>(|| StringTemplate { template: "" });
        ///     }
        /// }
        ///
        /// // The construction must be `const`.
        /// autoregister!(RegistrationFunc::new(
        ///     StringTemplate::register
        /// ));
        /// ```
        pub const fn new(register: RegisterFn) -> Self {
            Self(register)
        }
    }

    impl std::fmt::Debug for RegistrationFunc {
        fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            fmt.debug_tuple("RegistrationFunc").finish()
        }
    }

    // Create a new inventory for the auto-registration.
    inventory::collect!(RegistrationFunc);
}

#[cfg(feature = "tokio")]
pub use sync::*;

#[cfg(not(feature = "tokio"))]
pub use unsync::*;

/// Use `autoregister` to register a new [`RegistrationFunc`].
pub use inventory::submit as autoregister;
